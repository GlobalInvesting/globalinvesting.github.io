name: Update Extended Data (Bonds + Sentiment + Flows) - FINAL v4
on:
  schedule:
    - cron: '30 6 * * *'
  workflow_dispatch:

jobs:
  update-extended-data:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install requests beautifulsoup4 lxml --break-system-packages

      - name: Create directory
        run: mkdir -p extended-data

      - name: Scrape extended indicators
        run: |
          python3 << 'EOFPYTHON'
          import requests
          from bs4 import BeautifulSoup
          import json, re, os, time
          from datetime import date, datetime

          HEADERS = {
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          }

          CURRENCIES = ['USD', 'EUR', 'GBP', 'JPY', 'CAD', 'AUD', 'CHF', 'NZD']

          COUNTRY_NAMES = {
              'USD': ['United States'],
              'EUR': ['Euro Area'],
              'GBP': ['United Kingdom'],
              'JPY': ['Japan'],
              'CAD': ['Canada'],
              'AUD': ['Australia'],
              'CHF': ['Switzerland'],
              'NZD': ['New Zealand']
          }

          TE_URLS = {
              'bond10y':               'https://tradingeconomics.com/country-list/government-bond-yield?continent=world',
              'consumerConfidence':    'https://tradingeconomics.com/country-list/consumer-confidence?continent=world',
              'businessConfidence':    'https://tradingeconomics.com/country-list/business-confidence?continent=world',
              'capitalFlows':          'https://tradingeconomics.com/country-list/capital-flows?continent=world',
              'fdi':                   'https://tradingeconomics.com/country-list/foreign-direct-investment?continent=world',
              'inflationExpectations': 'https://tradingeconomics.com/country-list/inflation-expectations?continent=world',
          }

          def clean_num(text):
              if not text: return None
              text = str(text).strip().replace(',','').replace('%','')
              m = re.search(r'(-?\d+\.?\d*)', text)
              return float(m.group(1)) if m else None

          def parse_te_date(date_text):
              if not date_text: return str(date.today())
              date_text = date_text.strip()
              try:
                  # "Feb/26" or "Jan/26"
                  m = re.match(r'^([A-Za-z]{3})/(\d{2})$', date_text)
                  if m:
                      yr = '20' + m.group(2)
                      dt = datetime.strptime(f"{m.group(1)} {yr}", '%b %Y')
                      return dt.strftime('%Y-%m-15')
                  # "Feb 2026"
                  m = re.match(r'^([A-Za-z]{3})\s+(\d{4})$', date_text)
                  if m:
                      dt = datetime.strptime(f"{m.group(1)} {m.group(2)}", '%b %Y')
                      return dt.strftime('%Y-%m-15')
                  # Q1/2026 or Q4 2025
                  m = re.search(r'Q(\d)[/\s](\d{4})', date_text)
                  if m:
                      month = (int(m.group(1)) - 1) * 3 + 2
                      return f"{m.group(2)}-{month:02d}-15"
              except: pass
              return str(date.today())

          def normalize_confidence(value, currency, indicator):
              """
              Normalize confidence indices to base-100 scale (100 = neutral).

              Each index has a different native scale depending on the source:

              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚Currency â”‚ Index / Source                       â”‚ Native scale     â”‚ Normalization                                   â”‚
              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
              â”‚ USD     â”‚ Conference Board / Michigan (con)    â”‚ 0â€“150+           â”‚ Pass-through (already ~100-based)               â”‚
              â”‚ USD     â”‚ ISM Manufacturing PMI (biz)          â”‚ 0â€“100 (50=neut.) â”‚ Pass-through (not shifted; 50 â‰  100 by design)  â”‚
              â”‚ EUR     â”‚ European Commission (both)           â”‚ -100 to +100     â”‚ +100 shift â†’ neutral becomes 100               â”‚
              â”‚ GBP     â”‚ GfK Consumer (con)                   â”‚ -100 to +100     â”‚ +100 shift                                      â”‚
              â”‚ GBP     â”‚ CBI Industrial Trends (biz)          â”‚ -100 to +100     â”‚ +100 shift                                      â”‚
              â”‚ JPY     â”‚ Cabinet Office Consumer Conf (con)   â”‚ narrow 35â€“50     â”‚ ((v-40)/10)*15+100  (maps 40â†’100)               â”‚
              â”‚ JPY     â”‚ Tankan Large Mfg (biz)               â”‚ -100 to +100     â”‚ +100 shift                                      â”‚
              â”‚ AUD     â”‚ Westpac-MI Consumer Sent. (con)      â”‚ ~100-based       â”‚ Pass-through                                    â”‚
              â”‚ AUD     â”‚ NAB Business Confidence (biz)        â”‚ -100 to +100     â”‚ +100 shift                                      â”‚
              â”‚ CAD     â”‚ Conference Board Canada (con)        â”‚ ~100-based       â”‚ Pass-through                                    â”‚
              â”‚ CAD     â”‚ Ivey PMI (biz)                       â”‚ 0â€“100            â”‚ Pass-through                                    â”‚
              â”‚ CHF     â”‚ SECO Consumer Confidence (con)       â”‚ -150 to +50      â”‚ +130 shift (neutral â‰ˆ -30 â†’ 100)                â”‚
              â”‚ CHF     â”‚ KOF Economic Barometer (biz)         â”‚ ~100-based       â”‚ Pass-through                                    â”‚
              â”‚ NZD     â”‚ ANZ-Roy Morgan Consumer (con)        â”‚ ~100-based       â”‚ Pass-through                                    â”‚
              â”‚ NZD     â”‚ ANZ Business Outlook (biz)           â”‚ net balance -100/+100 BUT TE reports as is (e.g. 64.1) â”‚
              â”‚         â”‚                                      â”‚                  â”‚ Pass-through â€” do NOT add +100                  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

              KEY INSIGHT for NZD businessConfidence:
              ANZ Business Outlook is a net balance (% optimists minus % pessimists),
              so it can range roughly -100 to +100. Trading Economics reports it as-is
              (e.g. 64.1 in Jan/26 = 64% net optimists). Because the positive territory
              already indicates expansion and TE's value has no offset, we pass it through
              directly rather than shifting by +100 (which would produce a nonsensical 164.1).
              The dashboard scoring function handles this as a net-balance style index
              centered at 0 (positive = bullish, negative = bearish).
              """
              if value is None:
                  return None

              # ---------- consumerConfidence ----------
              if indicator == 'consumerConfidence':
                  if currency in ('EUR', 'GBP'):
                      # EC / GfK: -100/+100 â†’ shift to base 100
                      return round(value + 100, 2)
                  if currency == 'JPY':
                      # Cabinet Office: narrow scale centred ~45, neutral ~40
                      return round(((value - 40) / 10) * 15 + 100, 2)
                  if currency == 'CHF':
                      # SECO: long-run average â‰ˆ -30 â†’ map to 100
                      return round(value + 130, 2)
                  # USD, AUD, CAD, NZD: already ~100-based â†’ pass-through
                  return value

              # ---------- businessConfidence ----------
              if indicator == 'businessConfidence':
                  if currency in ('EUR', 'GBP', 'JPY', 'AUD'):
                      # EC / CBI / Tankan / NAB: all -100/+100 â†’ shift to base 100
                      return round(value + 100, 2)
                  if currency == 'NZD':
                      # ANZ Business Outlook: TE reports net balance directly (e.g. 64.1)
                      # Do NOT add +100 â€” pass through as-is.
                      # Positive = expansion, negative = contraction (centred at 0).
                      return round(value, 2)
                  # USD (ISM PMI), CAD (Ivey PMI), CHF (KOF ~100-based): pass-through
                  return value

              return value

          def scrape_te_table(url, label):
              print(f"\n{'='*50}\nSCRAPING: {label}\n{'='*50}")
              data, dates = {}, {}
              try:
                  r = requests.get(url, headers=HEADERS, timeout=20)
                  if r.status_code == 429:
                      print(f"  âš ï¸ Rate limited, waiting 30s...")
                      time.sleep(30)
                      r = requests.get(url, headers=HEADERS, timeout=20)
                  r.raise_for_status()

                  soup = BeautifulSoup(r.content, 'lxml')
                  table = soup.find('table', {'class': 'table'})
                  if not table:
                      print("  âŒ No table found"); return data, dates

                  headers_row = [h.get_text(strip=True).lower() for h in table.find_all('th')]
                  actual_idx = headers_row.index('actual') if 'actual' in headers_row else 1
                  # Use "last" column if "actual" not present (country-list pages use "Last")
                  if actual_idx == 1 and 'last' in headers_row:
                      actual_idx = headers_row.index('last')
                  date_idx   = headers_row.index('reference') if 'reference' in headers_row else None

                  for row in table.find_all('tr')[1:]:
                      cols = row.find_all('td')
                      if len(cols) < 2: continue
                      ctry = cols[0].get_text(strip=True)
                      for code, names in COUNTRY_NAMES.items():
                          if any(n.lower() in ctry.lower() for n in names):
                              raw_val = clean_num(cols[actual_idx].get_text(strip=True))
                              dt = parse_te_date(cols[date_idx].get_text(strip=True)) if date_idx and len(cols) > date_idx else str(date.today())
                              if raw_val is not None:
                                  # Normalize confidence indices to base-100 scale
                                  if label in ('consumerConfidence', 'businessConfidence'):
                                      normalized = normalize_confidence(raw_val, code, label)
                                      print(f"  âœ“ {code}: raw={raw_val} â†’ normalized={normalized} ({dt})")
                                      data[code]  = round(normalized, 4) if normalized is not None else None
                                  else:
                                      data[code]  = round(raw_val, 4)
                                      print(f"  âœ“ {code}: {raw_val} ({dt})")
                                  dates[code] = dt
                              break
              except Exception as e:
                  print(f"  âŒ {e}")
              return data, dates

          # â”€â”€ BOND YIELDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

          BOND_COUNTRY_MAP = {
              'USD': ['United States'],
              'EUR': ['Germany'],       # EUR proxy = Bund
              'GBP': ['United Kingdom'],
              'JPY': ['Japan'],
              'CAD': ['Canada'],
              'AUD': ['Australia'],
              'CHF': ['Switzerland'],
              'NZD': ['New Zealand'],
          }

          BOND_COUNTRY_SLUGS = {
              'USD': 'united-states',
              'EUR': 'germany',
              'GBP': 'united-kingdom',
              'JPY': 'japan',
              'CAD': 'canada',
              'AUD': 'australia',
              'CHF': 'switzerland',
              'NZD': 'new-zealand',
          }

          BOND_EXPECTED_RANGES = {
              'USD': (3.0, 6.0),
              'EUR': (1.5, 4.0),
              'GBP': (3.5, 5.5),
              'JPY': (0.5, 3.5),
              'CAD': (2.5, 5.0),
              'AUD': (3.5, 6.0),
              'CHF': (0.0, 2.0),
              'NZD': (3.5, 6.0),
          }

          def _extract_bonds_from_all_tables(soup):
              data, dates = {}, {}
              for table in soup.find_all('table'):
                  for row in table.find_all('tr'):
                      cols = row.find_all('td')
                      if len(cols) < 2: continue
                      ctry_text = cols[0].get_text(strip=True)
                      for code, names in BOND_COUNTRY_MAP.items():
                          if code in data: continue
                          if any(n.lower() in ctry_text.lower() for n in names):
                              for idx in [1, 2, 3]:
                                  if idx >= len(cols): continue
                                  val = clean_num(cols[idx].get_text(strip=True))
                                  if val is not None and 0 < val < 20:
                                      data[code]  = round(val, 3)
                                      dates[code] = str(date.today())
                                      print(f"  âœ“ {code}: {val}% (widget table)")
                                      break
              return data, dates

          def _bond_country_page_fallback(code):
              slug = BOND_COUNTRY_SLUGS.get(code)
              if not slug: return None, None
              min_val, max_val = BOND_EXPECTED_RANGES.get(code, (0.5, 10.0))

              url = f'https://tradingeconomics.com/{slug}/government-bond-yield'
              try:
                  r = requests.get(url, headers=HEADERS, timeout=15)
                  r.raise_for_status()
                  soup = BeautifulSoup(r.content, 'lxml')

                  for table in soup.find_all('table'):
                      for row in table.find_all('tr'):
                          cols = row.find_all('td')
                          for col in cols:
                              val = clean_num(col.get_text(strip=True))
                              if val is not None and min_val <= val <= max_val:
                                  print(f"  âœ“ {code}: {val}% (country page, range {min_val}-{max_val}%)")
                                  return round(val, 3), str(date.today())
              except Exception as e:
                  print(f"  âŒ Country page fallback {code}: {e}")
              return None, None

          def scrape_bonds():
              print(f"\n{'='*50}\nBOND YIELDS (3-level fallback)\n{'='*50}")
              data, dates = {}, {}

              try:
                  r = requests.get(TE_URLS['bond10y'], headers=HEADERS, timeout=20)
                  if r.status_code == 429:
                      print("  âš ï¸ Rate limited, waiting 30s...")
                      time.sleep(30)
                      r = requests.get(TE_URLS['bond10y'], headers=HEADERS, timeout=20)
                  r.raise_for_status()
                  soup = BeautifulSoup(r.content, 'lxml')

                  std_table = soup.find('table', {'class': 'table'})
                  if std_table:
                      headers_row = [h.get_text(strip=True).lower() for h in std_table.find_all('th')]
                      actual_idx = headers_row.index('actual') if 'actual' in headers_row else 1
                      if actual_idx == 1 and 'last' in headers_row:
                          actual_idx = headers_row.index('last')
                      date_idx = headers_row.index('reference') if 'reference' in headers_row else None
                      for row in std_table.find_all('tr')[1:]:
                          cols = row.find_all('td')
                          if len(cols) < 2: continue
                          ctry = cols[0].get_text(strip=True)
                          for code, names in BOND_COUNTRY_MAP.items():
                              if any(n.lower() in ctry.lower() for n in names):
                                  val = clean_num(cols[actual_idx].get_text(strip=True))
                                  dt  = parse_te_date(cols[date_idx].get_text(strip=True)) if date_idx and len(cols) > date_idx else str(date.today())
                                  min_v, max_v = BOND_EXPECTED_RANGES.get(code, (0, 20))
                                  if val is not None and min_v <= val <= max_v:
                                      data[code] = round(val, 3)
                                      dates[code] = dt
                                      print(f"  âœ“ {code}: {val}% ({dt})")
                                  break

                  missing = [c for c in CURRENCIES if c not in data]
                  if missing:
                      print(f"  Scanning all tables for: {', '.join(missing)}")
                      w_data, w_dates = _extract_bonds_from_all_tables(soup)
                      for code in missing:
                          if code in w_data:
                              min_v, max_v = BOND_EXPECTED_RANGES.get(code, (0, 20))
                              if min_v <= w_data[code] <= max_v:
                                  data[code]  = w_data[code]
                                  dates[code] = w_dates[code]
                              else:
                                  print(f"  âš ï¸ {code}: {w_data[code]}% out of range ({min_v}-{max_v}%) â†’ discarded")

              except Exception as e:
                  print(f"  âŒ TE bond page error: {e}")

              still_missing = [c for c in CURRENCIES if c not in data]
              if still_missing:
                  print(f"\n  Country-page fallback for: {', '.join(still_missing)}")
                  for code in still_missing:
                      val, dt = _bond_country_page_fallback(code)
                      if val is not None:
                          data[code]  = val
                          dates[code] = dt
                      time.sleep(1)

              print(f"\n  Found:   {[c for c in CURRENCIES if c in data]}")
              print(f"  Missing: {[c for c in CURRENCIES if c not in data]}")
              return data, dates

          # â”€â”€ MAIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          all_data  = {c: {} for c in CURRENCIES}
          all_dates = {c: {} for c in CURRENCIES}

          bond_data, bond_dates = scrape_bonds()
          for c in CURRENCIES:
              all_data[c]['bond10y']  = bond_data.get(c)
              all_dates[c]['bond10y'] = bond_dates.get(c, str(date.today()))
          time.sleep(2)

          for key, url in {k: v for k, v in TE_URLS.items() if k != 'bond10y'}.items():
              d, dt = scrape_te_table(url, key)
              for c in CURRENCIES:
                  all_data[c][key]  = d.get(c)
                  all_dates[c][key] = dt.get(c, str(date.today()))
              time.sleep(2)

          print(f"\n{'='*50}\nSAVING RESULTS\n{'='*50}")
          for curr in CURRENCIES:
              pkg = {
                  'lastUpdate': str(date.today()),
                  'source': 'TradingEconomics (?continent=world) â€” v4 NZD businessConf pass-through',
                  'data':   all_data[curr],
                  'dates':  all_dates[curr]
              }
              with open(f'extended-data/{curr}.json', 'w') as f:
                  json.dump(pkg, f, indent=2)
              available = [k for k, v in all_data[curr].items() if v is not None]
              missing   = [k for k in ['bond10y','consumerConfidence','businessConfidence',
                                        'capitalFlows','inflationExpectations'] if all_data[curr].get(k) is None]
              status = 'âœ…' if not missing else 'âš ï¸ '
              print(f"{status} {curr}: {', '.join(available) or 'NO DATA'}")
              if missing:
                  print(f"   Missing: {', '.join(missing)}")

          print("\nâœ… COMPLETE")
          EOFPYTHON

      - name: Commit and push
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git add extended-data/
          if git diff --quiet && git diff --staged --quiet; then
            echo "No changes"
          else
            git commit -m "ğŸ“Š Extended data $(date +'%Y-%m-%d') â€” v4 NZD pass-through fix"
            git pull --rebase origin main || true
            git push
          fi
