name: Update Interest Rates (100% Web Scraping + Dates)
on:
  schedule:
    - cron: '0 8 * * *'
  workflow_dispatch:

jobs:
  update-rates:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install requests beautifulsoup4 lxml --break-system-packages
      
      - name: Create rates directory
        run: mkdir -p rates
      
      - name: Fetch all rates via web scraping
        run: |
          cat > fetch_rates.py << 'EOFPYTHON'
          import requests
          from bs4 import BeautifulSoup
          import json
          import re
          from datetime import date, datetime
          import time
          import os
          
          HEADERS = {
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          }
          
          def clean_rate(text):
              if not text:
                  return None
              text = str(text).strip().replace('%', '').replace(',', '.')
              match = re.search(r'(-?\d+\.?\d*)', text)
              if match:
                  try:
                      val = float(match.group(1))
                      if -5 <= val <= 25:
                          return match.group(1)
                  except:
                      pass
              return None
          
          def parse_reference_date(date_text):
              if not date_text:
                  return str(date.today())
              
              date_text = date_text.strip()
              
              try:
                  m = re.match(r'^([A-Za-z]{3})/(\d{2})$', date_text)
                  if m:
                      month_str = m.group(1)
                      year_str = '20' + m.group(2)
                      dt = datetime.strptime(f"{month_str} {year_str}", '%b %Y')
                      return dt.strftime('%Y-%m-15')
                  
                  m = re.match(r'^([A-Za-z]{3})\s+(\d{4})$', date_text)
                  if m:
                      dt = datetime.strptime(f"{m.group(1)} {m.group(2)}", '%b %Y')
                      return dt.strftime('%Y-%m-15')
                  
                  if re.match(r'^\d{4}-\d{2}-\d{2}$', date_text):
                      return date_text
                  
                  m = re.match(r'^([A-Za-z]+)\s+(\d{1,2}),?\s+(\d{4})$', date_text)
                  if m:
                      dt = datetime.strptime(f"{m.group(1)} {m.group(2)} {m.group(3)}", '%B %d %Y')
                      return dt.strftime('%Y-%m-%d')
                      
              except Exception as e:
                  print(f"    Date parse error for '{date_text}': {e}")
              
              return str(date.today())

          # â”€â”€ NUEVO: Cargar histÃ³rico existente â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # En lugar de sobreescribir el JSON, cargamos el archivo actual y
          # agregamos la nueva observaciÃ³n al principio (mÃ¡s reciente primero).
          # Esto preserva el histÃ³rico acumulado desde el backfill inicial.
          def load_existing_observations(currency):
              path = f'rates/{currency}.json'
              if not os.path.exists(path):
                  return []
              try:
                  with open(path) as f:
                      data = json.load(f)
                  return data.get('observations', [])
              except Exception as e:
                  print(f"    âš ï¸ No se pudo leer histÃ³rico existente para {currency}: {e}")
                  return []

          def merge_observations(existing, new_obs):
              """
              Combina la nueva observaciÃ³n con el histÃ³rico existente.
              - Si ya existe una observaciÃ³n con la misma fecha, la sobreescribe
                (para corregir valores en caso de revisiÃ³n del BC).
              - Mantiene ordenamiento mÃ¡s reciente primero.
              - Limita el histÃ³rico a 36 meses para no inflar el JSON.
              """
              # Crear diccionario por fecha para deduplicar
              obs_map = {o['date']: o for o in existing}
              
              # Agregar/sobreescribir con la nueva observaciÃ³n
              obs_map[new_obs['date']] = new_obs
              
              # Ordenar mÃ¡s reciente primero
              sorted_obs = sorted(obs_map.values(), key=lambda x: x['date'], reverse=True)
              
              # Limitar a 36 meses de histÃ³rico
              return sorted_obs[:36]
          
          def fetch_trading_economics():
              print("\n" + "="*70)
              print("SOURCE 1: Trading Economics (with Reference date)")
              print("="*70)
              
              try:
                  url = "https://tradingeconomics.com/country-list/interest-rate?continent=world"
                  r = requests.get(url, headers=HEADERS, timeout=15)
                  if r.status_code == 429:
                      print("  âš ï¸ Rate limited, waiting 30s...")
                      time.sleep(30)
                      r = requests.get(url, headers=HEADERS, timeout=15)
                  r.raise_for_status()
                  soup = BeautifulSoup(r.content, 'lxml')
                  
                  rates = {}
                  country_map = {
                      'United States': 'USD',
                      'Euro Area': 'EUR', 
                      'United Kingdom': 'GBP',
                      'Japan': 'JPY',
                      'Canada': 'CAD',
                      'Australia': 'AUD',
                      'Switzerland': 'CHF',
                      'New Zealand': 'NZD'
                  }
                  
                  table = soup.find('table', {'class': 'table'})
                  if not table:
                      print("  âŒ No table found")
                      return rates
                  
                  headers_row = table.find('thead')
                  header_texts = []
                  if headers_row:
                      header_texts = [th.get_text(strip=True).lower()
                                      for th in headers_row.find_all('th')]
                  
                  last_idx = 1
                  reference_idx = 3
                  
                  if header_texts:
                      if 'last' in header_texts:
                          last_idx = header_texts.index('last')
                      elif 'actual' in header_texts:
                          last_idx = header_texts.index('actual')
                      if 'reference' in header_texts:
                          reference_idx = header_texts.index('reference')
                  
                  for row in table.find_all('tr')[1:]:
                      cols = row.find_all('td')
                      if len(cols) < 2:
                          continue
                      
                      country = cols[0].get_text(strip=True)
                      
                      for country_name, currency in country_map.items():
                          if country_name.lower() in country.lower():
                              rate_text = cols[last_idx].get_text(strip=True) if last_idx < len(cols) else ''
                              rate = clean_rate(rate_text)
                              
                              ref_date_text = ''
                              if reference_idx < len(cols):
                                  ref_date_text = cols[reference_idx].get_text(strip=True)
                              
                              reference_date = parse_reference_date(ref_date_text)
                              
                              if rate is not None:
                                  rates[currency] = {
                                      'value': rate,
                                      'date': reference_date,
                                      'rawDate': ref_date_text,
                                      'source': 'TradingEconomics'
                                  }
                                  print(f"  âœ“ {currency}: {rate}% | Reference: '{ref_date_text}' â†’ {reference_date}")
                              break
                  
                  return rates
                  
              except Exception as e:
                  print(f"  âŒ Error: {e}")
                  return {}
          
          def fetch_global_rates_fallback(currency):
              urls = {
                  'USD': 'central-bank-america/fed-interest-rate.aspx',
                  'EUR': 'central-bank-europe/ecb-interest-rate.aspx',
                  'GBP': 'central-bank-england/boe-interest-rate.aspx',
                  'JPY': 'central-bank-japan/boj-interest-rate.aspx',
                  'CHF': 'central-bank-switzerland/snb-interest-rate.aspx',
                  'CAD': 'central-bank-canada/boc-interest-rate.aspx',
                  'AUD': 'central-bank-australia/rba-interest-rate.aspx',
                  'NZD': 'central-bank-new-zealand/rbnz-interest-rate.aspx'
              }
              
              if currency not in urls:
                  return None
              
              try:
                  url = f"https://www.global-rates.com/en/interest-rates/central-banks/{urls[currency]}"
                  r = requests.get(url, headers=HEADERS, timeout=10)
                  soup = BeautifulSoup(r.content, 'lxml')
                  
                  for table in soup.find_all('table'):
                      rows = table.find_all('tr')
                      if len(rows) >= 2:
                          cols = rows[1].find_all('td')
                          if len(cols) >= 2:
                              rate = clean_rate(cols[1].get_text(strip=True))
                              if rate:
                                  date_text = cols[0].get_text(strip=True)
                                  data_date = parse_reference_date(date_text)
                                  return {
                                      'value': rate,
                                      'date': data_date,
                                      'rawDate': date_text,
                                      'source': 'GlobalRates'
                                  }
              except Exception as e:
                  print(f"    Error fetching fallback for {currency}: {e}")
              
              return None
          
          # ============================================
          # MAIN EXECUTION
          # ============================================
          
          print("\n" + "="*70)
          print("ACTUALIZANDO TASAS CON ACUMULACIÃ“N HISTÃ“RICA")
          print("="*70)
          
          final_rates = {}
          
          te_rates = fetch_trading_economics()
          final_rates.update(te_rates)
          
          time.sleep(1)
          
          currencies_needed = ['USD', 'EUR', 'GBP', 'JPY', 'CAD', 'AUD', 'CHF', 'NZD']
          missing = [c for c in currencies_needed if c not in final_rates]
          
          if missing:
              print("\n" + "="*70)
              print(f"SOURCE 2: Global-Rates.com fallback for: {', '.join(missing)}")
              print("="*70)
              
              for currency in missing:
                  result = fetch_global_rates_fallback(currency)
                  if result:
                      final_rates[currency] = result
                      print(f"  âœ“ {currency}: {result['value']}% | date: {result['date']}")
                  time.sleep(0.5)
          
          # ============================================
          # GUARDAR CON ACUMULACIÃ“N HISTÃ“RICA
          # â”€â”€ DIFERENCIA CLAVE vs workflow original â”€â”€
          # En lugar de sobreescribir todo el JSON, cargamos el histÃ³rico
          # previo y agregamos la nueva observaciÃ³n, preservando el backfill.
          # ============================================
          
          print("\n" + "="*70)
          print("GUARDANDO CON ACUMULACIÃ“N HISTÃ“RICA")
          print("="*70)
          
          today = str(date.today())
          
          for currency, data in final_rates.items():
              # Cargar histÃ³rico existente (del backfill o ejecuciones previas)
              existing_obs = load_existing_observations(currency)
              
              # Crear nueva observaciÃ³n de hoy
              new_observation = {
                  'value': data['value'],
                  'date': data.get('date', today),
                  'rawDate': data.get('rawDate', ''),
                  'source': data['source']
              }
              
              # Combinar con histÃ³rico (deduplicando por fecha)
              merged_obs = merge_observations(existing_obs, new_observation)
              
              rate_data = {
                  'observations': merged_obs,
                  'lastUpdate': today,
                  'totalObservations': len(merged_obs)
              }
              
              with open(f'rates/{currency}.json', 'w') as f:
                  json.dump(rate_data, f, indent=2)
              
              print(f"  ğŸ’¾ {currency}: {data['value']}% | total histÃ³rico: {len(merged_obs)} obs | mÃ¡s antigua: {merged_obs[-1]['date']}")
          
          missing_final = [c for c in currencies_needed if c not in final_rates]
          
          if missing_final:
              print(f"\nâŒ MISSING: {', '.join(missing_final)}")
              exit(1)
          else:
              print(f"\nâœ… TODAS LAS DIVISAS ACTUALIZADAS CON HISTÃ“RICO PRESERVADO!")
          
          EOFPYTHON
          
          python fetch_rates.py
      
      - name: Display rates summary
        run: |
          echo ""
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘         INTEREST RATES SUMMARY                 â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          for currency in USD EUR GBP JPY CAD AUD CHF NZD; do
            if [ -f "rates/$currency.json" ]; then
              echo "[$currency]"
              python3 -c "
          import json
          with open('rates/$currency.json') as f:
              data = json.load(f)
              obs = data['observations']
              print(f\"  Rate actual:    {obs[0]['value']}%\")
              print(f\"  PerÃ­odo:        {obs[0]['date']}\")
              print(f\"  Total histÃ³rico: {len(obs)} observaciones\")
              print(f\"  MÃ¡s antigua:    {obs[-1]['date']} = {obs[-1]['value']}%\")
              print(f\"  Actualizado:    {data['lastUpdate']}\")
          "
              echo ""
            else
              echo "[$currency] - No data"
              echo ""
            fi
          done
      
      - name: Commit and push
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git add rates/
          if git diff --quiet && git diff --staged --quiet; then
            echo "No changes"
          else
            git commit -m "ğŸ”„ Rates $(date +'%Y-%m-%d') + histÃ³rico acumulado"
            git pull --rebase origin main || true
            git push
          fi
